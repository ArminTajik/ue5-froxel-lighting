/*=============================================================================
        FroxelCommon.ush - Common shader code for froxel lighting
=============================================================================*/
// #pragma once replaced with ifndef/define

#ifndef FROXEL_COMMON_USH
#define FROXEL_COMMON_USH

#include "/Engine/Private/Common.ush"
#include "/Engine/Generated/GeneratedUniformBuffers.ush"

/**
 * for reference, UE creates FroxelCommon.variables from C++ side
struct FroxelCommon {
    int4 GridSize; // x = numX, y = numY, z = numZ, w = totalCount
    float NearCm;
    float FarCm;
    int2 ViewportSize; // in pixels
    float2 InvTilePx; // 1/tileW, 1/tileH (viewport space)
};
*/

struct FFroxelLightData {
    float3 PositionWS;
    float Radius;
    // float3 Color;
    // float Intensity;
};

// Helpers ----------------------------------------------------------------
uint FroxelIndex(uint gx, uint gy, uint gz) {
    return gx + gy * (uint)FroxelCommon.GridSize.x + gz * (uint)FroxelCommon.GridSize.x * (uint)FroxelCommon.GridSize.y;
}

uint FroxelIndexSafe(uint3 g) {
    uint idx = FroxelIndex(g.x, g.y, g.z);
    return min(idx, (uint)(FroxelCommon.GridSize.w - 1));
}

uint FroxelIndexFromViewportUV(float2 uv, uint z) {
    uint gx = min(uv.x, 1.0f) * FroxelCommon.GridSize.x;
    uint gy = min(uv.y, 1.0f) * FroxelCommon.GridSize.y;
    z = min(z, (uint)(FroxelCommon.GridSize.z - 1));
    return FroxelIndex(gx, gy, z);
}


uint FroxelIndexFromPix(uint2 pix, uint z) {
    uint gx = pix.x / max(FroxelCommon.TileSize.x, 1);
    uint gy = pix.y / max(FroxelCommon.TileSize.y, 1);
    gx = min(gx, (uint)(FroxelCommon.GridSize.x - 1));
    gy = min(gy, (uint)(FroxelCommon.GridSize.y - 1));
    z = min(z, (uint)(FroxelCommon.GridSize.z - 1));
    return FroxelIndex(gx, gy, z);
}


uint FroxelZFromLinearDepthCm(float depthCm) {
    float nearCm = FroxelCommon.NearCm;
    float farCm = max(FroxelCommon.FarCm, nearCm + 1e-3);

    depthCm = clamp(depthCm, nearCm, farCm);
#if FROXEL_LOGARITHMIC_DEPTH
    float t = log(depthCm / nearCm) / log(farCm / nearCm);
#else
    float t = (depthCm - nearCm) / (farCm - nearCm);
#endif

    uint z = (uint)min(floor(saturate(t) * FroxelCommon.GridSize.z), FroxelCommon.GridSize.z - 1);

    return z;
}


bool SphereViewRectAndZ(float3 posWS, float radiusCm, float3 preViewTranslationLow, matrix worldToView,
                        matrix worldToClip, uint4 viewRectMinAndSize, out uint2 tileMin, out uint2 tileMax,
                        out uint zMin,
                        out uint zMax) {

    uint4 gridSize = (uint4)FroxelCommon.GridSize;
    float near = FroxelCommon.NearCm;
    float far = FroxelCommon.FarCm;
    uint2 viewRectSize = FroxelCommon.ViewportSize;
    // uint2  viewRectMin  = viewRectMinAndSize.xy;
    // uint2  viewRectSize = viewRectMinAndSize.zw;
    float2 invTilePx = FroxelCommon.InvTilePx;

    // worldToView = FroxelCommon.ViewMatrix;
    // worldToClip = FroxelCommon.ProjectionMatrix;
    // int2 viewRectMin = FroxelCommon.ViewRectMinPx;
    float3 posTW = posWS + preViewTranslationLow;
    // posWS + preViewTranslationLow;
    // float3 posTW = posWS;
    float3 posVS = mul(float4(posTW, 1.0), worldToView).xyz;
    float4 posCS = mul(float4(posTW, 1.0), worldToClip);

    // hardcoded posCS

    float dCenter = -posVS.z;

    // early out if behind near plane
    float dMin = dCenter - radiusCm;
    float dMax = dCenter + radiusCm;
    // if (dMax < near)
    //     return false;
    // if (dMin > far)
    //     return false;

    // project sphere center to clip space

    // if (posCS.w <= 0.0)
    //     return false;

    float2 ndc = posCS.xy / posCS.w; // normalized device coords [-1, 1]
    float2 uv = ndc * 0.5f + 0.5f; // convert to [0, 1] UV
    float2 posPx = uv * viewRectSize; // to pixel space
    // float2 uv  = float2(0.5, 0.5);
    // float2 posPx = uv * viewportSize;

    // getting screen-space radius using the projectionâ€™s X scale (approx).
    float projXX = abs(worldToClip[0][0]);
    float rPx = (radiusCm * 100.0 * projXX) * (viewRectSize.x * 0.5f) / posCS.w;
    rPx = max(rPx, 0.5f); // to avoid zero division later

    // rPx = 10.0f; // TEMP for testing

    // // getting screen-space radius using derivative (more accurate)
    // float2 dx = ddx(posPx);
    // float2 dy = ddy(posPx);
    // float rPx = length(dx) + length(dy);
    // rPx = max(rPx * radiusCm, 0.5f); // to avoid zero division later

    // Pixel AABB
    float2 posPxMin = posPx - rPx;
    float2 posPxMax = posPx + rPx;

    // pixel to tile (XY range)
    uint2 tMin = (uint2)max(floor(posPxMin * invTilePx), 0.0);
    uint2 tMax = (uint2)ceil(posPxMax * invTilePx);

    tMin.x = min(tMin.x, gridSize.x - 1);
    tMin.y = min(tMin.y, gridSize.y - 1);
    tMax.x = min(tMax.x, gridSize.x);
    tMax.y = min(tMax.y, gridSize.y);

    // Compute Z range
    float d0 = clamp(dMin, near, far);
    float d1 = clamp(dMax, near, far);

    uint z0 = FroxelZFromLinearDepthCm(d0);
    uint z1 = FroxelZFromLinearDepthCm(d1);

    tileMin = tMin;
    tileMax = max(tMin + 1, tMax); // making sure at lease 1 tile is covered

    zMin = min(z0, z1);
    zMax = max(z0 + 1, z1);
    zMax = min(zMax, gridSize.z);

    return true;
}


#endif